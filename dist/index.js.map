{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import { Address, OpCode, Tx, TxIn, TxOut } from \"@ts-bitcoin/core\";\r\nimport RpcClient, { Config } from \"bitcoind-rpc\";\r\n\r\nconst fromHash = function (o: ParseConfig, config?: Config): Promise<BpuTx> {\r\n  if (!config) {\r\n    console.log(\"split from hash without config\");\r\n    config = {\r\n      protocol: \"http\",\r\n      user: process.env.BITCOIN_USERNAME\r\n        ? process.env.BITCOIN_USERNAME\r\n        : \"root\",\r\n      pass: process.env.BITCOIN_PASSWORD\r\n        ? process.env.BITCOIN_PASSWORD\r\n        : \"bitcoin\",\r\n      host: process.env.BITCOIN_IP ? process.env.BITCOIN_IP : \"127.0.0.1\",\r\n      port: process.env.BITCOIN_PORT ? process.env.BITCOIN_PORT : \"8332\",\r\n    };\r\n  }\r\n  const rpc = new RpcClient(config);\r\n  return new Promise(function (resolve, reject) {\r\n    if ((o.tx as ByTxId)?.h) {\r\n      rpc.getRawTransaction(\r\n        (o.tx as ByTxId).h,\r\n        async function (err, transaction) {\r\n          if (err) {\r\n            reject(err);\r\n          } else {\r\n            if (o.tx) {\r\n              (o.tx as ByRawTx).r = transaction.result;\r\n              const result = await fromTx(o);\r\n              resolve(result);\r\n            } else {\r\n              reject(new Error(`Failed to get raw tx from RPC endpoint`));\r\n            }\r\n          }\r\n        }\r\n      );\r\n    }\r\n  });\r\n};\r\n\r\nconst fromTx = function (o: ParseConfig): Promise<BpuTx> {\r\n  const transaction = (o.tx as ByRawTx).r;\r\n  return new Promise(function (resolve, reject) {\r\n    if (transaction) {\r\n      const gene = Tx.fromHex(transaction);\r\n      const inputs = gene.txIns ? collect(o, \"in\", gene.txIns) : [];\r\n      const outputs = gene.txOuts ? collect(o, \"out\", gene.txOuts) : [];\r\n      resolve({\r\n        tx: { h: gene.id() },\r\n        in: inputs as In[],\r\n        out: outputs as Out[],\r\n        lock: gene.nLockTime,\r\n      });\r\n    } else {\r\n      reject(new Error(`No transaction`));\r\n    }\r\n  });\r\n};\r\n\r\nconst collect = (\r\n  o: ParseConfig,\r\n  type: any,\r\n  xputs: (TxIn | TxOut)[]\r\n): In[] | Out[] => {\r\n  const xputsres: any = [];\r\n  if (!o.transform)\r\n    o.transform = function (r: any) {\r\n      return r;\r\n    };\r\n  xputs.forEach((xput, xput_index) => {\r\n    if (xput.script) {\r\n      const xputres = { i: xput_index, tape: [] } as any;\r\n      let tape_i = 0;\r\n      let cell_i = 0;\r\n      let cell: any = [];\r\n      xput.script.chunks.forEach(function (c, chunk_index) {\r\n        if (c.buf) {\r\n          const b = c.buf.toString(\"base64\");\r\n          const s = c.buf.toString(\"utf8\");\r\n          let splitter: string | undefined;\r\n          let isSplitter = false;\r\n          if (o.split && Array.isArray(o.split)) {\r\n            o.split.forEach(function (setting: any) {\r\n              if (\r\n                (setting.token && setting.token.s && setting.token.s === s) ||\r\n                (setting.token && setting.token.b && setting.token.b === b)\r\n              ) {\r\n                splitter = setting.include;\r\n                isSplitter = true;\r\n              }\r\n            });\r\n          }\r\n          if (isSplitter && o.transform) {\r\n            if (splitter === \"l\") {\r\n              const item = o.transform(\r\n                {\r\n                  b: c.buf.toString(\"base64\"),\r\n                  s: c.buf.toString(\"utf8\"),\r\n                  ii: chunk_index,\r\n                  i: cell_i++,\r\n                },\r\n                c\r\n              );\r\n\r\n              cell.push(item);\r\n              xputres.tape.push({ cell: cell, i: tape_i++ });\r\n              cell = [];\r\n              cell_i = 0;\r\n            } else if (splitter === \"r\") {\r\n              xputres.tape.push({ cell: cell, i: tape_i++ });\r\n              const item = o.transform(\r\n                {\r\n                  b: c.buf.toString(\"base64\"),\r\n                  s: c.buf.toString(\"utf8\"),\r\n                  ii: chunk_index,\r\n                  i: cell_i++,\r\n                },\r\n                c\r\n              );\r\n              cell = [item];\r\n              cell_i = 1;\r\n            } else if (splitter === \"c\") {\r\n              xputres.tape.push({ cell: cell, i: tape_i++ });\r\n              const item = o.transform(\r\n                {\r\n                  b: c.buf.toString(\"base64\"),\r\n                  s: c.buf.toString(\"utf8\"),\r\n                  ii: chunk_index,\r\n                  i: 0,\r\n                },\r\n                c\r\n              );\r\n              xputres.tape.push({ cell: [item], i: tape_i++ });\r\n              cell = [];\r\n              cell_i = 0;\r\n            } else {\r\n              xputres.tape.push({ cell: cell, i: tape_i++ });\r\n              cell = [];\r\n              cell_i = 0;\r\n            }\r\n          } else {\r\n            if (o.transform) {\r\n              const item = o.transform(\r\n                {\r\n                  b: c.buf.toString(\"base64\"),\r\n                  s: c.buf.toString(\"utf8\"),\r\n                  ii: chunk_index,\r\n                  i: cell_i++,\r\n                },\r\n                c\r\n              );\r\n              cell.push(item);\r\n            }\r\n          }\r\n        } else {\r\n          // Opcode case\r\n          if (typeof c.opCodeNum !== \"undefined\") {\r\n            const op = c.opCodeNum;\r\n            const ops = OpCode[op].toString();\r\n            let splitter: string | undefined;\r\n            let isSplitter = false;\r\n            if (o.split && Array.isArray(o.split)) {\r\n              o.split.forEach(function (setting: any) {\r\n                if (\r\n                  (setting.token &&\r\n                    setting.token.op &&\r\n                    setting.token.op === op) ||\r\n                  (setting.token &&\r\n                    setting.token.ops &&\r\n                    setting.token.ops === ops)\r\n                ) {\r\n                  splitter = setting.include;\r\n                  isSplitter = true;\r\n                }\r\n              });\r\n            }\r\n            if (isSplitter && o.transform) {\r\n              if (splitter === \"l\") {\r\n                const item = o.transform(\r\n                  { op: op, ops: ops, ii: chunk_index, i: cell_i++ },\r\n                  c\r\n                );\r\n                cell.push(item);\r\n                xputres.tape.push({ cell: cell, i: tape_i++ });\r\n                cell = [];\r\n                cell_i = 0;\r\n              } else if (splitter === \"r\") {\r\n                xputres.tape.push({ cell: cell, i: tape_i++ });\r\n                const item = o.transform(\r\n                  { op: op, ops: ops, ii: chunk_index, i: cell_i++ },\r\n                  c\r\n                );\r\n                cell = [item];\r\n                cell_i = 1;\r\n              } else if (splitter === \"c\") {\r\n                xputres.tape.push({ cell: cell, i: tape_i++ });\r\n                const item = o.transform(\r\n                  { op: op, ops: ops, ii: chunk_index, i: cell_i++ },\r\n                  c\r\n                );\r\n                xputres.tape.push({ cell: [item], i: tape_i++ });\r\n                cell = [];\r\n                cell_i = 0;\r\n              } else {\r\n                xputres.tape.push({ cell: cell, i: tape_i++ });\r\n                cell = [];\r\n                cell_i = 0;\r\n              }\r\n            } else {\r\n              if (o.transform) {\r\n                const item = o.transform(\r\n                  { op: op, ops: ops, ii: chunk_index, i: cell_i++ },\r\n                  c\r\n                );\r\n                cell.push(item);\r\n              }\r\n            }\r\n          } else {\r\n            if (o.transform) {\r\n              cell.push(\r\n                o.transform({ op: c, ii: chunk_index, i: cell_i++ }, c)\r\n              );\r\n            }\r\n          }\r\n        }\r\n      });\r\n\r\n      if (cell.length > 0) xputres.tape.push({ cell: cell, i: tape_i++ });\r\n      if (type === \"in\") {\r\n        const sender = {\r\n          h: (xput as TxIn).txHashBuf?.toString(\"hex\"),\r\n          i: xput.scriptVi.toNumber(),\r\n        } as any;\r\n        const address = Address.fromTxInScript(xput.script).toString();\r\n        if (address && address.length > 0) {\r\n          sender.a = address;\r\n        }\r\n        xputres.e = sender;\r\n        xputres.seq = (xput as TxIn).nSequence;\r\n      } else if (type === \"out\") {\r\n        const receiver = {\r\n          v: (xput as TxOut).valueBn.toNumber(),\r\n          i: xput_index,\r\n        } as any;\r\n        const address = Address.fromTxOutScript(xput.script).toString();\r\n        if (address && address.length > 0) {\r\n          receiver.a = address;\r\n        }\r\n        xputres.e = receiver;\r\n      }\r\n      xputsres.push(xputres);\r\n    }\r\n  });\r\n\r\n  return xputsres;\r\n};\r\n\r\nexport const parse = async (o: ParseConfig, config?: any): Promise<BpuTx> => {\r\n  if (o.tx) {\r\n    if ((o.tx as ByTxId).h) {\r\n      return await fromHash(o, config);\r\n    } else if ((o.tx as ByRawTx).r) {\r\n      return await fromTx(o);\r\n    }\r\n  }\r\n  throw new Error(`Invalid Tx`);\r\n};\r\n\r\nexport type Cell = {\r\n  op?: number;\r\n  ops?: string;\r\n  b?: string;\r\n  s?: string;\r\n  ii: number;\r\n  i: number;\r\n  h?: string;\r\n  f?: string;\r\n  ls?: string;\r\n  lh?: string;\r\n  lf?: string;\r\n  lb?: string;\r\n};\r\n\r\nexport type Tape = {\r\n  cell: Cell[];\r\n  i: number;\r\n};\r\n\r\nexport type Out = {\r\n  tape: Tape[];\r\n  i: number;\r\n  e: {\r\n    i: number;\r\n    a: string | false;\r\n    v: number;\r\n  };\r\n};\r\nexport type In = {\r\n  i: number;\r\n  e: {\r\n    h: string;\r\n    a: string;\r\n    v?: number;\r\n  };\r\n};\r\nexport type BpuTx = {\r\n  out: Out[];\r\n  in?: In[];\r\n  tx: {\r\n    h?: string;\r\n    r?: string;\r\n  };\r\n  lock?: number;\r\n};\r\n\r\nexport type ByRawTx = {\r\n  r: string;\r\n};\r\n\r\nexport type ByTxId = {\r\n  h: string;\r\n};\r\n\r\nexport type SplitConfig = {\r\n  token: {\r\n    op?: number;\r\n    ops?: string;\r\n    s?: string;\r\n    b?: string;\r\n  };\r\n  include?: string;\r\n};\r\n\r\nexport type ParseConfig = {\r\n  tx: ByRawTx | ByTxId;\r\n  split?: SplitConfig[];\r\n  transform?: (o: any, c: any) => Object;\r\n};\r\n\r\nexport type { Config } from \"bitcoind-rpc\";\r\n"],"names":["fromTx","o","transaction","tx","r","Promise","resolve","reject","gene","Tx","fromHex","inputs","txIns","collect","outputs","txOuts","h","id","in","out","lock","nLockTime","Error","type","xputs","xputsres","transform","forEach","xput","xput_index","script","xputres","i","tape","tape_i","cell_i","cell","chunks","c","chunk_index","buf","splitter","b","toString","s","isSplitter","split","Array","isArray","setting","token","include","item","ii","push","opCodeNum","op","ops","OpCode","length","_xput$txHashBuf","sender","txHashBuf","scriptVi","toNumber","address","Address","fromTxInScript","a","e","seq","nSequence","receiver","v","valueBn","fromTxOutScript","config","_exit","_temp4","_result3","_temp3","console","log","protocol","user","process","env","BITCOIN_USERNAME","pass","BITCOIN_PASSWORD","host","BITCOIN_IP","port","BITCOIN_PORT","rpc","RpcClient","_o$tx","getRawTransaction","err","_temp2","_temp","result","then","fromHash","_await$fromHash","_await$fromTx"],"mappings":"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"}