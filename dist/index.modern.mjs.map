{"version":3,"file":"index.modern.mjs","sources":["../src/index.ts"],"sourcesContent":["import { Address, OpCode, Tx, TxIn, TxOut } from \"@ts-bitcoin/core\";\r\nimport RpcClient, { Config } from \"bitcoind-rpc\";\r\n\r\nconst fromHash = function (o: ParseConfig, config?: Config): Promise<BpuTx> {\r\n  if (!config) {\r\n    console.log(\"split from hash without config\");\r\n    config = {\r\n      protocol: \"http\",\r\n      user: process.env.BITCOIN_USERNAME\r\n        ? process.env.BITCOIN_USERNAME\r\n        : \"root\",\r\n      pass: process.env.BITCOIN_PASSWORD\r\n        ? process.env.BITCOIN_PASSWORD\r\n        : \"bitcoin\",\r\n      host: process.env.BITCOIN_IP ? process.env.BITCOIN_IP : \"127.0.0.1\",\r\n      port: process.env.BITCOIN_PORT ? process.env.BITCOIN_PORT : \"8332\",\r\n    };\r\n  }\r\n  const rpc = new RpcClient(config);\r\n  return new Promise(function (resolve, reject) {\r\n    if ((o.tx as ByTxId)?.h) {\r\n      rpc.getRawTransaction(\r\n        (o.tx as ByTxId).h,\r\n        async function (err, transaction) {\r\n          if (err) {\r\n            reject(err);\r\n          } else {\r\n            if (o.tx) {\r\n              (o.tx as ByRawTx).r = transaction.result;\r\n              const result = await fromTx(o);\r\n              resolve(result);\r\n            } else {\r\n              reject(new Error(`Failed to get raw tx from RPC endpoint`));\r\n            }\r\n          }\r\n        }\r\n      );\r\n    }\r\n  });\r\n};\r\n\r\nconst fromTx = function (o: ParseConfig): Promise<BpuTx> {\r\n  const transaction = (o.tx as ByRawTx).r;\r\n  return new Promise(function (resolve, reject) {\r\n    if (transaction) {\r\n      const gene = Tx.fromHex(transaction);\r\n      const inputs = gene.txIns ? collect(o, \"in\", gene.txIns) : [];\r\n      const outputs = gene.txOuts ? collect(o, \"out\", gene.txOuts) : [];\r\n      resolve({\r\n        tx: { h: gene.id() },\r\n        in: inputs as In[],\r\n        out: outputs as Out[],\r\n        lock: gene.nLockTime,\r\n      });\r\n    } else {\r\n      reject(new Error(`No transaction`));\r\n    }\r\n  });\r\n};\r\n\r\nconst collect = (\r\n  o: ParseConfig,\r\n  type: any,\r\n  xputs: (TxIn | TxOut)[]\r\n): In[] | Out[] => {\r\n  const xputsres: any = [];\r\n  if (!o.transform)\r\n    o.transform = function (r: any) {\r\n      return r;\r\n    };\r\n  xputs.forEach((xput, xput_index) => {\r\n    if (xput.script) {\r\n      const xputres = { i: xput_index, tape: [] } as any;\r\n      let tape_i = 0;\r\n      let cell_i = 0;\r\n      let cell: any = [];\r\n      xput.script.chunks.forEach(function (c, chunk_index) {\r\n        if (c.buf) {\r\n          const b = c.buf.toString(\"base64\");\r\n          const s = c.buf.toString(\"utf8\");\r\n          let splitter: string | undefined;\r\n          let isSplitter = false;\r\n          if (o.split && Array.isArray(o.split)) {\r\n            o.split.forEach(function (setting: any) {\r\n              if (\r\n                (setting.token && setting.token.s && setting.token.s === s) ||\r\n                (setting.token && setting.token.b && setting.token.b === b)\r\n              ) {\r\n                splitter = setting.include;\r\n                isSplitter = true;\r\n              }\r\n            });\r\n          }\r\n          if (isSplitter && o.transform) {\r\n            if (splitter === \"l\") {\r\n              const item = o.transform(\r\n                {\r\n                  b: c.buf.toString(\"base64\"),\r\n                  s: c.buf.toString(\"utf8\"),\r\n                  ii: chunk_index,\r\n                  i: cell_i++,\r\n                },\r\n                c\r\n              );\r\n\r\n              cell.push(item);\r\n              xputres.tape.push({ cell: cell, i: tape_i++ });\r\n              cell = [];\r\n              cell_i = 0;\r\n            } else if (splitter === \"r\") {\r\n              xputres.tape.push({ cell: cell, i: tape_i++ });\r\n              const item = o.transform(\r\n                {\r\n                  b: c.buf.toString(\"base64\"),\r\n                  s: c.buf.toString(\"utf8\"),\r\n                  ii: chunk_index,\r\n                  i: cell_i++,\r\n                },\r\n                c\r\n              );\r\n              cell = [item];\r\n              cell_i = 1;\r\n            } else if (splitter === \"c\") {\r\n              xputres.tape.push({ cell: cell, i: tape_i++ });\r\n              const item = o.transform(\r\n                {\r\n                  b: c.buf.toString(\"base64\"),\r\n                  s: c.buf.toString(\"utf8\"),\r\n                  ii: chunk_index,\r\n                  i: 0,\r\n                },\r\n                c\r\n              );\r\n              xputres.tape.push({ cell: [item], i: tape_i++ });\r\n              cell = [];\r\n              cell_i = 0;\r\n            } else {\r\n              xputres.tape.push({ cell: cell, i: tape_i++ });\r\n              cell = [];\r\n              cell_i = 0;\r\n            }\r\n          } else {\r\n            if (o.transform) {\r\n              const item = o.transform(\r\n                {\r\n                  b: c.buf.toString(\"base64\"),\r\n                  s: c.buf.toString(\"utf8\"),\r\n                  ii: chunk_index,\r\n                  i: cell_i++,\r\n                },\r\n                c\r\n              );\r\n              cell.push(item);\r\n            }\r\n          }\r\n        } else {\r\n          // Opcode case\r\n          if (typeof c.opCodeNum !== \"undefined\") {\r\n            const op = c.opCodeNum;\r\n            const ops = OpCode[op].toString();\r\n            let splitter: string | undefined;\r\n            let isSplitter = false;\r\n            if (o.split && Array.isArray(o.split)) {\r\n              o.split.forEach(function (setting: any) {\r\n                if (\r\n                  (setting.token &&\r\n                    setting.token.op &&\r\n                    setting.token.op === op) ||\r\n                  (setting.token &&\r\n                    setting.token.ops &&\r\n                    setting.token.ops === ops)\r\n                ) {\r\n                  splitter = setting.include;\r\n                  isSplitter = true;\r\n                }\r\n              });\r\n            }\r\n            if (isSplitter && o.transform) {\r\n              if (splitter === \"l\") {\r\n                const item = o.transform(\r\n                  { op: op, ops: ops, ii: chunk_index, i: cell_i++ },\r\n                  c\r\n                );\r\n                cell.push(item);\r\n                xputres.tape.push({ cell: cell, i: tape_i++ });\r\n                cell = [];\r\n                cell_i = 0;\r\n              } else if (splitter === \"r\") {\r\n                xputres.tape.push({ cell: cell, i: tape_i++ });\r\n                const item = o.transform(\r\n                  { op: op, ops: ops, ii: chunk_index, i: cell_i++ },\r\n                  c\r\n                );\r\n                cell = [item];\r\n                cell_i = 1;\r\n              } else if (splitter === \"c\") {\r\n                xputres.tape.push({ cell: cell, i: tape_i++ });\r\n                const item = o.transform(\r\n                  { op: op, ops: ops, ii: chunk_index, i: cell_i++ },\r\n                  c\r\n                );\r\n                xputres.tape.push({ cell: [item], i: tape_i++ });\r\n                cell = [];\r\n                cell_i = 0;\r\n              } else {\r\n                xputres.tape.push({ cell: cell, i: tape_i++ });\r\n                cell = [];\r\n                cell_i = 0;\r\n              }\r\n            } else {\r\n              if (o.transform) {\r\n                const item = o.transform(\r\n                  { op: op, ops: ops, ii: chunk_index, i: cell_i++ },\r\n                  c\r\n                );\r\n                cell.push(item);\r\n              }\r\n            }\r\n          } else {\r\n            if (o.transform) {\r\n              cell.push(\r\n                o.transform({ op: c, ii: chunk_index, i: cell_i++ }, c)\r\n              );\r\n            }\r\n          }\r\n        }\r\n      });\r\n\r\n      if (cell.length > 0) xputres.tape.push({ cell: cell, i: tape_i++ });\r\n      if (type === \"in\") {\r\n        const sender = {\r\n          h: (xput as TxIn).txHashBuf?.toString(\"hex\"),\r\n          i: xput.scriptVi.toNumber(),\r\n        } as any;\r\n        const address = Address.fromTxInScript(xput.script).toString();\r\n        if (address && address.length > 0) {\r\n          sender.a = address;\r\n        }\r\n        xputres.e = sender;\r\n        xputres.seq = (xput as TxIn).nSequence;\r\n      } else if (type === \"out\") {\r\n        const receiver = {\r\n          v: (xput as TxOut).valueBn.toNumber(),\r\n          i: xput_index,\r\n        } as any;\r\n        const address = Address.fromTxOutScript(xput.script).toString();\r\n        if (address && address.length > 0) {\r\n          receiver.a = address;\r\n        }\r\n        xputres.e = receiver;\r\n      }\r\n      xputsres.push(xputres);\r\n    }\r\n  });\r\n\r\n  return xputsres;\r\n};\r\n\r\nexport const parse = async (o: ParseConfig, config?: any): Promise<BpuTx> => {\r\n  if (o.tx) {\r\n    if ((o.tx as ByTxId).h) {\r\n      return await fromHash(o, config);\r\n    } else if ((o.tx as ByRawTx).r) {\r\n      return await fromTx(o);\r\n    }\r\n  }\r\n  throw new Error(`Invalid Tx`);\r\n};\r\n\r\nexport type Cell = {\r\n  op?: number;\r\n  ops?: string;\r\n  b?: string;\r\n  s?: string;\r\n  ii: number;\r\n  i: number;\r\n  h?: string;\r\n  f?: string;\r\n  ls?: string;\r\n  lh?: string;\r\n  lf?: string;\r\n  lb?: string;\r\n};\r\n\r\nexport type Tape = {\r\n  cell: Cell[];\r\n  i: number;\r\n};\r\n\r\nexport type Out = {\r\n  tape: Tape[];\r\n  i: number;\r\n  e: {\r\n    i: number;\r\n    a: string | false;\r\n    v: number;\r\n  };\r\n};\r\nexport type In = {\r\n  i: number;\r\n  e: {\r\n    h: string;\r\n    a: string;\r\n    v?: number;\r\n  };\r\n};\r\nexport type BpuTx = {\r\n  out: Out[];\r\n  in?: In[];\r\n  tx: {\r\n    h?: string;\r\n    r?: string;\r\n  };\r\n  lock?: number;\r\n};\r\n\r\nexport type ByRawTx = {\r\n  r: string;\r\n};\r\n\r\nexport type ByTxId = {\r\n  h: string;\r\n};\r\n\r\nexport type SplitConfig = {\r\n  token: {\r\n    op?: number;\r\n    ops?: string;\r\n    s?: string;\r\n    b?: string;\r\n  };\r\n  include?: string;\r\n};\r\n\r\nexport type ParseConfig = {\r\n  tx: ByRawTx | ByTxId;\r\n  split?: SplitConfig[];\r\n  transform?: (o: any, c: any) => Object;\r\n};\r\n\r\nexport type { Config } from \"bitcoind-rpc\";\r\n"],"names":["fromTx","o","transaction","tx","r","Promise","resolve","reject","gene","Tx","fromHex","inputs","txIns","collect","outputs","txOuts","h","id","in","out","lock","nLockTime","Error","type","xputs","xputsres","transform","forEach","xput","xput_index","script","xputres","i","tape","tape_i","cell_i","cell","chunks","c","chunk_index","buf","b","toString","s","splitter","isSplitter","split","Array","isArray","setting","token","include","item","ii","push","opCodeNum","op","ops","OpCode","length","_xput$txHashBuf","sender","txHashBuf","scriptVi","toNumber","address","Address","fromTxInScript","a","e","seq","nSequence","receiver","v","valueBn","fromTxOutScript","parse","async","config","console","log","protocol","user","process","env","BITCOIN_USERNAME","pass","BITCOIN_PASSWORD","host","BITCOIN_IP","port","BITCOIN_PORT","rpc","RpcClient","_o$tx","getRawTransaction","err","result","fromHash"],"mappings":"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"}