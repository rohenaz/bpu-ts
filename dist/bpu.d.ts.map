{"mappings":";AAyCA,YAAY;IACV,EAAE,CAAC,EAAE,MAAM,CAAC;IACZ,GAAG,CAAC,EAAE,MAAM,CAAC;IACb,CAAC,CAAC,EAAE,MAAM,CAAC;IACX,CAAC,CAAC,EAAE,MAAM,CAAC;IACX,EAAE,EAAE,MAAM,CAAC;IACX,CAAC,EAAE,MAAM,CAAC;IACV,CAAC,CAAC,EAAE,MAAM,CAAC;IACX,CAAC,CAAC,EAAE,MAAM,CAAC;IACX,EAAE,CAAC,EAAE,MAAM,CAAC;IACZ,EAAE,CAAC,EAAE,MAAM,CAAC;IACZ,EAAE,CAAC,EAAE,MAAM,CAAC;IACZ,EAAE,CAAC,EAAE,MAAM,CAAC;CACb,CAAC;AAEF,YAAY;IACV,IAAI,EAAE,IAAI,EAAE,CAAC;IACb,CAAC,EAAE,MAAM,CAAC;CACX,CAAC;AAEF,WAAW;IACT,IAAI,EAAE,IAAI,EAAE,CAAC;IACb,CAAC,EAAE,MAAM,CAAC;IACV,CAAC,EAAE;QACD,CAAC,EAAE,MAAM,CAAC;QACV,CAAC,EAAE,MAAM,GAAG,KAAK,CAAC;QAClB,CAAC,EAAE,MAAM,CAAC;KACX,CAAC;CACH,CAAC;AAEF,UAAU;IACR,CAAC,EAAE,MAAM,CAAC;IACV,CAAC,EAAE;QACD,CAAC,EAAE,MAAM,CAAC;QACV,CAAC,EAAE,MAAM,CAAC;QACV,CAAC,CAAC,EAAE,MAAM,CAAC;KACZ,CAAC;CACH,CAAC;AAEF,oBAAoB;IAClB,GAAG,EAAE,GAAG,EAAE,CAAC;IACX,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC;IACV,EAAE,EAAE;QACF,CAAC,CAAC,EAAE,MAAM,CAAC;QACX,CAAC,CAAC,EAAE,MAAM,CAAC;KACZ,CAAC;IACF,IAAI,CAAC,EAAE,MAAM,CAAC;CACf,CAAC;AAsNF,eAAe;IACb,CAAC,EAAE,MAAM,CAAC;CACX,CAAC;AAEF,cAAc;IACZ,CAAC,EAAE,MAAM,CAAC;CACX,CAAC;AAEF,mBAAmB;IACjB,KAAK,EAAE;QACL,EAAE,CAAC,EAAE,MAAM,CAAC;QACZ,GAAG,CAAC,EAAE,MAAM,CAAC;QACb,CAAC,CAAC,EAAE,MAAM,CAAC;QACX,CAAC,CAAC,EAAE,MAAM,CAAC;KACZ,CAAC;IACF,OAAO,CAAC,EAAE,MAAM,CAAC;CAClB,CAAC;AAEF,0BAA0B;IACxB,EAAE,EAAE,OAAO,GAAG,MAAM,CAAC;IACrB,KAAK,CAAC,EAAE,WAAW,EAAE,CAAC;IACtB,SAAS,CAAC,EAAE,CAAC,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,KAAK,MAAM,CAAC;CACxC,CAAC;AAEF,OAAO,MAAM,WAAY,WAAW,WAAW,GAAG,KAAG,QAAQ,KAAK,CASjE,CAAC;AAWF,YAAY,EAAE,MAAM,EAAE,MAAM,cAAc,CAAC;AAE3C,kBAAkB;IAChB,OAAO,YAAY,CAAC;IACpB,SAAS,EAAE,OAAO,SAAS,CAAC;CAC7B,CAAC;AAEF,QAAA,MAAM,GAAG,EAAE,GAA0B,CAAC;AACtC,eAAe,GAAG,CAAC","sources":["src/src/index.ts","src/index.ts"],"sourcesContent":[null,"import { Address, OpCode, Tx, TxIn, TxOut } from \"@ts-bitcoin/core\";\r\nimport RpcClient, { Config } from \"bitcoind-rpc\";\r\n\r\nconst fromHash = function (o: ParseConfig, config?: Config): Promise<BpuTx> {\r\n  if (!config) {\r\n    console.log(\"split from hash without config\");\r\n    config = {\r\n      protocol: \"http\",\r\n      user: process.env.BITCOIN_USERNAME\r\n        ? process.env.BITCOIN_USERNAME\r\n        : \"root\",\r\n      pass: process.env.BITCOIN_PASSWORD\r\n        ? process.env.BITCOIN_PASSWORD\r\n        : \"bitcoin\",\r\n      host: process.env.BITCOIN_IP ? process.env.BITCOIN_IP : \"127.0.0.1\",\r\n      port: process.env.BITCOIN_PORT ? process.env.BITCOIN_PORT : \"8332\",\r\n    };\r\n  }\r\n  const rpc = new RpcClient(config);\r\n  return new Promise(function (resolve, reject) {\r\n    if ((o.tx as ByTxId)?.h) {\r\n      rpc.getRawTransaction(\r\n        (o.tx as ByTxId).h,\r\n        async function (err, transaction) {\r\n          if (err) {\r\n            reject(err);\r\n          } else {\r\n            if (o.tx) {\r\n              (o.tx as ByRawTx).r = transaction.result;\r\n              const result = await fromTx(o);\r\n              resolve(result);\r\n            } else {\r\n              reject(new Error(`Failed to get raw tx from RPC endpoint`));\r\n            }\r\n          }\r\n        }\r\n      );\r\n    }\r\n  });\r\n};\r\n\r\ntype Cell = {\r\n  op?: number;\r\n  ops?: string;\r\n  b?: string;\r\n  s?: string;\r\n  ii: number;\r\n  i: number;\r\n  h?: string;\r\n  f?: string;\r\n  ls?: string;\r\n  lh?: string;\r\n  lf?: string;\r\n  lb?: string;\r\n};\r\n\r\ntype Tape = {\r\n  cell: Cell[];\r\n  i: number;\r\n};\r\n\r\ntype Out = {\r\n  tape: Tape[];\r\n  i: number;\r\n  e: {\r\n    i: number;\r\n    a: string | false;\r\n    v: number;\r\n  };\r\n};\r\n\r\ntype In = {\r\n  i: number;\r\n  e: {\r\n    h: string;\r\n    a: string;\r\n    v?: number;\r\n  };\r\n};\r\n\r\nexport type BpuTx = {\r\n  out: Out[];\r\n  in?: In[];\r\n  tx: {\r\n    h?: string;\r\n    r?: string;\r\n  };\r\n  lock?: number;\r\n};\r\n\r\nconst fromTx = function (o: ParseConfig): Promise<BpuTx> {\r\n  const transaction = (o.tx as ByRawTx).r;\r\n  return new Promise(function (resolve, reject) {\r\n    if (transaction) {\r\n      const gene = Tx.fromHex(transaction);\r\n      const inputs = gene.txIns ? collect(o, \"in\", gene.txIns) : [];\r\n      const outputs = gene.txOuts ? collect(o, \"out\", gene.txOuts) : [];\r\n      resolve({\r\n        tx: { h: gene.hash().toString() },\r\n        in: inputs as In[],\r\n        out: outputs as Out[],\r\n        lock: gene.nLockTime,\r\n      });\r\n    } else {\r\n      reject(new Error(`No transaction`));\r\n    }\r\n  });\r\n};\r\nconst collect = function (\r\n  o: ParseConfig,\r\n  type: any,\r\n  xputs: (TxIn | TxOut)[]\r\n): In[] | Out[] {\r\n  const xputsres: any = [];\r\n  if (!o.transform)\r\n    o.transform = function (r: any) {\r\n      return r;\r\n    };\r\n  xputs.forEach(function (xput, xput_index) {\r\n    if (xput.script) {\r\n      const xputres = { i: xput_index, tape: [] } as any;\r\n      let tape_i = 0;\r\n      let cell_i = 0;\r\n      let cell: any = [];\r\n      xput.script.chunks.forEach(function (c, chunk_index) {\r\n        if (c.buf) {\r\n          const b = c.buf.toString(\"base64\");\r\n          const s = c.buf.toString(\"utf8\");\r\n          let splitter: string | undefined;\r\n          let isSplitter = false;\r\n          if (o.split && Array.isArray(o.split)) {\r\n            o.split.forEach(function (setting: any) {\r\n              if (\r\n                (setting.token && setting.token.s && setting.token.s === s) ||\r\n                (setting.token && setting.token.b && setting.token.b === b)\r\n              ) {\r\n                splitter = setting.include;\r\n                isSplitter = true;\r\n              }\r\n            });\r\n          }\r\n          if (isSplitter && o.transform) {\r\n            if (splitter === \"l\") {\r\n              const item = o.transform(\r\n                {\r\n                  b: c.buf.toString(\"base64\"),\r\n                  s: c.buf.toString(\"utf8\"),\r\n                  ii: chunk_index,\r\n                  i: cell_i++,\r\n                },\r\n                c\r\n              );\r\n\r\n              cell.push(item);\r\n              xputres.tape.push({ cell: cell, i: tape_i++ });\r\n              cell = [];\r\n              cell_i = 0;\r\n            } else if (splitter === \"r\") {\r\n              xputres.tape.push({ cell: cell, i: tape_i++ });\r\n              const item = o.transform(\r\n                {\r\n                  b: c.buf.toString(\"base64\"),\r\n                  s: c.buf.toString(\"utf8\"),\r\n                  ii: chunk_index,\r\n                  i: cell_i++,\r\n                },\r\n                c\r\n              );\r\n              cell = [item];\r\n              cell_i = 1;\r\n            } else if (splitter === \"c\") {\r\n              xputres.tape.push({ cell: cell, i: tape_i++ });\r\n              const item = o.transform(\r\n                {\r\n                  b: c.buf.toString(\"base64\"),\r\n                  s: c.buf.toString(\"utf8\"),\r\n                  ii: chunk_index,\r\n                  i: 0,\r\n                },\r\n                c\r\n              );\r\n              xputres.tape.push({ cell: [item], i: tape_i++ });\r\n              cell = [];\r\n              cell_i = 0;\r\n            } else {\r\n              xputres.tape.push({ cell: cell, i: tape_i++ });\r\n              cell = [];\r\n              cell_i = 0;\r\n            }\r\n          } else {\r\n            if (o.transform) {\r\n              const item = o.transform(\r\n                {\r\n                  b: c.buf.toString(\"base64\"),\r\n                  s: c.buf.toString(\"utf8\"),\r\n                  ii: chunk_index,\r\n                  i: cell_i++,\r\n                },\r\n                c\r\n              );\r\n              cell.push(item);\r\n            }\r\n          }\r\n        } else {\r\n          if (typeof c.opCodeNum !== \"undefined\") {\r\n            const op = c.opCodeNum;\r\n            const ops = OpCode[op].toString();\r\n            let splitter: string | undefined;\r\n            let isSplitter = false;\r\n            if (o.split && Array.isArray(o.split)) {\r\n              o.split.forEach(function (setting: any) {\r\n                if (\r\n                  (setting.token &&\r\n                    setting.token.op &&\r\n                    setting.token.op === op) ||\r\n                  (setting.token &&\r\n                    setting.token.ops &&\r\n                    setting.token.ops === ops)\r\n                ) {\r\n                  splitter = setting.include;\r\n                  isSplitter = true;\r\n                }\r\n              });\r\n            }\r\n            if (isSplitter && o.transform) {\r\n              if (splitter === \"l\") {\r\n                const item = o.transform(\r\n                  { op: op, ops: ops, ii: chunk_index, i: cell_i++ },\r\n                  c\r\n                );\r\n                cell.push(item);\r\n                xputres.tape.push({ cell: cell, i: tape_i++ });\r\n                cell = [];\r\n                cell_i = 0;\r\n              } else if (splitter === \"r\") {\r\n                xputres.tape.push({ cell: cell, i: tape_i++ });\r\n                const item = o.transform(\r\n                  { op: op, ops: ops, ii: chunk_index, i: cell_i++ },\r\n                  c\r\n                );\r\n                cell = [item];\r\n                cell_i = 1;\r\n              } else if (splitter === \"c\") {\r\n                xputres.tape.push({ cell: cell, i: tape_i++ });\r\n                const item = o.transform(\r\n                  { op: op, ops: ops, ii: chunk_index, i: cell_i++ },\r\n                  c\r\n                );\r\n                xputres.tape.push({ cell: [item], i: tape_i++ });\r\n                cell = [];\r\n                cell_i = 0;\r\n              } else {\r\n                xputres.tape.push({ cell: cell, i: tape_i++ });\r\n                cell = [];\r\n                cell_i = 0;\r\n              }\r\n            } else {\r\n              if (o.transform) {\r\n                const item = o.transform(\r\n                  { op: op, ops: ops, ii: chunk_index, i: cell_i++ },\r\n                  c\r\n                );\r\n                cell.push(item);\r\n              }\r\n            }\r\n          } else {\r\n            if (o.transform) {\r\n              cell.push(\r\n                o.transform({ op: c, ii: chunk_index, i: cell_i++ }, c)\r\n              );\r\n            }\r\n          }\r\n        }\r\n      });\r\n\r\n      if (cell.length > 0) xputres.tape.push({ cell: cell, i: tape_i++ });\r\n      if (type === \"in\") {\r\n        const sender = {\r\n          h: (xput as TxIn).txHashBuf?.toString(\"hex\"),\r\n          i: xput.scriptVi,\r\n        } as any;\r\n        const address = Address.fromTxInScript(xput.script).toString();\r\n        if (address && address.length > 0) {\r\n          sender.a = address;\r\n        }\r\n        xputres.e = sender;\r\n        xputres.seq = (xput as TxIn).nSequence;\r\n      } else if (type === \"out\") {\r\n        const receiver = { v: (xput as TxOut).valueBn, i: xput_index } as any;\r\n        const address = Address.fromTxOutScript(xput.script).toString();\r\n        if (address && address.length > 0) {\r\n          receiver.a = address;\r\n        }\r\n        xputres.e = receiver;\r\n      }\r\n      xputsres.push(xputres);\r\n    }\r\n  });\r\n\r\n  return xputsres;\r\n};\r\n\r\ntype ByRawTx = {\r\n  r: string;\r\n};\r\n\r\ntype ByTxId = {\r\n  h: string;\r\n};\r\n\r\ntype SplitConfig = {\r\n  token: {\r\n    op?: number;\r\n    ops?: string;\r\n    s?: string;\r\n    b?: string;\r\n  };\r\n  include?: string;\r\n};\r\n\r\nexport type ParseConfig = {\r\n  tx: ByRawTx | ByTxId;\r\n  split?: SplitConfig[];\r\n  transform?: (o: any, c: any) => Object;\r\n};\r\n\r\nexport const parse = (o: ParseConfig, config?: any): Promise<BpuTx> => {\r\n  if (o.tx) {\r\n    if ((o.tx as ByTxId).h) {\r\n      return fromHash(o, config);\r\n    } else if ((o.tx as ByRawTx).r) {\r\n      return fromTx(o);\r\n    }\r\n  }\r\n  throw new Error(`Invalid Tx`);\r\n};\r\n\r\nif (require.main === module) {\r\n  if (process.argv.length >= 3) {\r\n    const hash = process.argv[2];\r\n    fromHash({ tx: { h: hash } }).then(function (result) {\r\n      console.log(result);\r\n    });\r\n  }\r\n}\r\n\r\nexport type { Config } from \"bitcoind-rpc\";\r\n\r\nexport type BPU = {\r\n  parse: typeof parse;\r\n  RpcClient: typeof RpcClient;\r\n};\r\n\r\nconst bpu: BPU = { parse, RpcClient };\r\nexport default bpu;\r\n"],"names":[],"version":3,"file":"bpu.d.ts.map","sourceRoot":"../"}