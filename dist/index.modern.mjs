import{Tx as t,OpCode as o,Address as s}from"@ts-bitcoin/core";import i from"bitcoind-rpc";const n=function(o){const s=o.tx.r;return new Promise(function(i,n){if(s){const n=t.fromHex(s),r=n.txIns?e(o,"in",n.txIns):[],c=n.txOuts?e(o,"out",n.txOuts):[];i({tx:{h:n.id()},in:r,out:c,lock:n.nLockTime})}else n(new Error("No transaction"))})},e=(t,i,n)=>{const e=[];return t.transform||(t.transform=function(t){return t}),n.forEach((n,r)=>{if(n.script){const f={i:r,tape:[]};let p=0,u=0,a=[];if(n.script.chunks.forEach(function(s,i){if(s.buf){const o=s.buf.toString("base64"),n=s.buf.toString("utf8");let e,r=!1;if(t.split&&Array.isArray(t.split)&&t.split.forEach(function(t){(t.token&&t.token.s&&t.token.s===n||t.token&&t.token.b&&t.token.b===o)&&(e=t.include,r=!0)}),r&&t.transform)if("l"===e){const o=t.transform({b:s.buf.toString("base64"),s:s.buf.toString("utf8"),ii:i,i:u++},s);a.push(o),f.tape.push({cell:a,i:p++}),a=[],u=0}else if("r"===e){f.tape.push({cell:a,i:p++});const o=t.transform({b:s.buf.toString("base64"),s:s.buf.toString("utf8"),ii:i,i:u++},s);a=[o],u=1}else if("c"===e){f.tape.push({cell:a,i:p++});const o=t.transform({b:s.buf.toString("base64"),s:s.buf.toString("utf8"),ii:i,i:0},s);f.tape.push({cell:[o],i:p++}),a=[],u=0}else f.tape.push({cell:a,i:p++}),a=[],u=0;else if(t.transform){const o=t.transform({b:s.buf.toString("base64"),s:s.buf.toString("utf8"),ii:i,i:u++},s);a.push(o)}}else if(void 0!==s.opCodeNum){const n=s.opCodeNum,e=o[n].toString();let r,c=!1;if(t.split&&Array.isArray(t.split)&&t.split.forEach(function(t){(t.token&&t.token.op&&t.token.op===n||t.token&&t.token.ops&&t.token.ops===e)&&(r=t.include,c=!0)}),c&&t.transform)if("l"===r){const o=t.transform({op:n,ops:e,ii:i,i:u++},s);a.push(o),f.tape.push({cell:a,i:p++}),a=[],u=0}else if("r"===r){f.tape.push({cell:a,i:p++});const o=t.transform({op:n,ops:e,ii:i,i:u++},s);a=[o],u=1}else if("c"===r){f.tape.push({cell:a,i:p++});const o=t.transform({op:n,ops:e,ii:i,i:u++},s);f.tape.push({cell:[o],i:p++}),a=[],u=0}else f.tape.push({cell:a,i:p++}),a=[],u=0;else if(t.transform){const o=t.transform({op:n,ops:e,ii:i,i:u++},s);a.push(o)}}else t.transform&&a.push(t.transform({op:s,ii:i,i:u++},s))}),a.length>0&&f.tape.push({cell:a,i:p++}),"in"===i){var c;const t={h:null==(c=n.txHashBuf)?void 0:c.toString("hex"),i:n.scriptVi.toNumber()},o=s.fromTxInScript(n.script).toString();o&&o.length>0&&(t.a=o),f.e=t,f.seq=n.nSequence}else if("out"===i){const t={v:n.valueBn.toNumber(),i:r},o=s.fromTxOutScript(n.script).toString();o&&o.length>0&&(t.a=o),f.e=t}e.push(f)}}),e},r=async(t,o)=>{if(t.tx){if(t.tx.h)return await function(t,o){o||(console.log("split from hash without config"),o={protocol:"http",user:process.env.BITCOIN_USERNAME?process.env.BITCOIN_USERNAME:"root",pass:process.env.BITCOIN_PASSWORD?process.env.BITCOIN_PASSWORD:"bitcoin",host:process.env.BITCOIN_IP?process.env.BITCOIN_IP:"127.0.0.1",port:process.env.BITCOIN_PORT?process.env.BITCOIN_PORT:"8332"});const s=new i(o);return new Promise(function(o,i){var e;null!=(e=t.tx)&&e.h&&s.getRawTransaction(t.tx.h,async function(s,e){if(s)i(s);else if(t.tx){t.tx.r=e.result;const s=await n(t);o(s)}else i(new Error("Failed to get raw tx from RPC endpoint"))})})}(t,o);if(t.tx.r)return await n(t)}throw new Error("Invalid Tx")};export{r as parse};
//# sourceMappingURL=index.modern.mjs.map
