{"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAGA,MAAM,WAAW,SAAU,CAAc,EAAE,MAAe,EAAkB;IAC1E,IAAI,CAAC,QAAQ;QACX,QAAQ,GAAG,CAAC;QACZ,SAAS;YACP,UAAU;YACV,MAAM,QAAQ,GAAG,CAAC,gBAAgB,GAC9B,QAAQ,GAAG,CAAC,gBAAgB,GAC5B,MAAM;YACV,MAAM,QAAQ,GAAG,CAAC,gBAAgB,GAC9B,QAAQ,GAAG,CAAC,gBAAgB,GAC5B,SAAS;YACb,MAAM,QAAQ,GAAG,CAAC,UAAU,GAAG,QAAQ,GAAG,CAAC,UAAU,GAAG,WAAW;YACnE,MAAM,QAAQ,GAAG,CAAC,YAAY,GAAG,QAAQ,GAAG,CAAC,YAAY,GAAG,MAAM;QACpE;IACF,CAAC;IACD,MAAM,MAAM,IAAI,CAAA,GAAA,kBAAQ,EAAE;IAC1B,OAAO,IAAI,QAAQ,SAAU,OAAO,EAAE,MAAM,EAAE;QAC5C,IAAK,EAAE,EAAE,EAAa,GACpB,IAAI,iBAAiB,CACnB,AAAC,EAAE,EAAE,CAAY,CAAC,EAClB,eAAgB,GAAG,EAAE,WAAW,EAAE;YAChC,IAAI,KACF,OAAO;iBAEP,IAAI,EAAE,EAAE,EAAE;gBACP,EAAE,EAAE,CAAa,CAAC,GAAG,YAAY,MAAM;gBACxC,MAAM,SAAS,MAAM,OAAO;gBAC5B,QAAQ;YACV,OACE,OAAO,IAAI,MAAM,CAAC,sCAAsC,CAAC;QAG/D;IAGN;AACF;AAmDA,MAAM,SAAS,SAAU,CAAc,EAAkB;IACvD,MAAM,cAAc,AAAC,EAAE,EAAE,CAAa,CAAC;IACvC,OAAO,IAAI,QAAQ,SAAU,OAAO,EAAE,MAAM,EAAE;QAC5C,IAAI,aAAa;YACf,MAAM,OAAO,CAAA,GAAA,SAAE,AAAD,EAAE,OAAO,CAAC;YACxB,MAAM,SAAS,KAAK,KAAK,GAAG,QAAQ,GAAG,MAAM,KAAK,KAAK,IAAI,EAAE;YAC7D,MAAM,UAAU,KAAK,MAAM,GAAG,QAAQ,GAAG,OAAO,KAAK,MAAM,IAAI,EAAE;YACjE,QAAQ;gBACN,IAAI;oBAAE,GAAG,KAAK,IAAI,GAAG,QAAQ;gBAAG;gBAChC,IAAI;gBACJ,KAAK;gBACL,MAAM,KAAK,SAAS;YACtB;QACF,OACE,OAAO,IAAI,MAAM,CAAC,cAAc,CAAC;IAErC;AACF;AAEA,MAAM,UAAU,SACd,CAAc,EACd,IAAS,EACT,KAAuB,EACT;IACd,MAAM,WAAgB,EAAE;IACxB,IAAI,CAAC,EAAE,SAAS,EACd,EAAE,SAAS,GAAG,SAAU,CAAM,EAAE;QAC9B,OAAO;IACT;IACF,MAAM,OAAO,CAAC,SAAU,IAAI,EAAE,UAAU,EAAE;QACxC,IAAI,KAAK,MAAM,EAAE;YACf,MAAM,UAAU;gBAAE,GAAG;gBAAY,MAAM,EAAE;YAAC;YAC1C,IAAI,SAAS;YACb,IAAI,SAAS;YACb,IAAI,OAAY,EAAE;YAClB,KAAK,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,SAAU,CAAC,EAAE,WAAW,EAAE;gBACnD,IAAI,EAAE,GAAG,EAAE;oBACT,MAAM,IAAI,EAAE,GAAG,CAAC,QAAQ,CAAC;oBACzB,MAAM,IAAI,EAAE,GAAG,CAAC,QAAQ,CAAC;oBACzB,IAAI;oBACJ,IAAI,aAAa,KAAK;oBACtB,IAAI,EAAE,KAAK,IAAI,MAAM,OAAO,CAAC,EAAE,KAAK,GAClC,EAAE,KAAK,CAAC,OAAO,CAAC,SAAU,OAAY,EAAE;wBACtC,IACE,AAAC,QAAQ,KAAK,IAAI,QAAQ,KAAK,CAAC,CAAC,IAAI,QAAQ,KAAK,CAAC,CAAC,KAAK,KACxD,QAAQ,KAAK,IAAI,QAAQ,KAAK,CAAC,CAAC,IAAI,QAAQ,KAAK,CAAC,CAAC,KAAK,GACzD;4BACA,WAAW,QAAQ,OAAO;4BAC1B,aAAa,IAAI;wBACnB,CAAC;oBACH;oBAEF,IAAI,cAAc,EAAE,SAAS,EAAE;wBAC7B,IAAI,aAAa,KAAK;4BACpB,MAAM,OAAO,EAAE,SAAS,CACtB;gCACE,GAAG,EAAE,GAAG,CAAC,QAAQ,CAAC;gCAClB,GAAG,EAAE,GAAG,CAAC,QAAQ,CAAC;gCAClB,IAAI;gCACJ,GAAG;4BACL,GACA;4BAGF,KAAK,IAAI,CAAC;4BACV,QAAQ,IAAI,CAAC,IAAI,CAAC;gCAAE,MAAM;gCAAM,GAAG;4BAAS;4BAC5C,OAAO,EAAE;4BACT,SAAS;wBACX,OAAO,IAAI,aAAa,KAAK;4BAC3B,QAAQ,IAAI,CAAC,IAAI,CAAC;gCAAE,MAAM;gCAAM,GAAG;4BAAS;4BAC5C,MAAM,OAAO,EAAE,SAAS,CACtB;gCACE,GAAG,EAAE,GAAG,CAAC,QAAQ,CAAC;gCAClB,GAAG,EAAE,GAAG,CAAC,QAAQ,CAAC;gCAClB,IAAI;gCACJ,GAAG;4BACL,GACA;4BAEF,OAAO;gCAAC;6BAAK;4BACb,SAAS;wBACX,OAAO,IAAI,aAAa,KAAK;4BAC3B,QAAQ,IAAI,CAAC,IAAI,CAAC;gCAAE,MAAM;gCAAM,GAAG;4BAAS;4BAC5C,MAAM,OAAO,EAAE,SAAS,CACtB;gCACE,GAAG,EAAE,GAAG,CAAC,QAAQ,CAAC;gCAClB,GAAG,EAAE,GAAG,CAAC,QAAQ,CAAC;gCAClB,IAAI;gCACJ,GAAG;4BACL,GACA;4BAEF,QAAQ,IAAI,CAAC,IAAI,CAAC;gCAAE,MAAM;oCAAC;iCAAK;gCAAE,GAAG;4BAAS;4BAC9C,OAAO,EAAE;4BACT,SAAS;wBACX,OAAO;4BACL,QAAQ,IAAI,CAAC,IAAI,CAAC;gCAAE,MAAM;gCAAM,GAAG;4BAAS;4BAC5C,OAAO,EAAE;4BACT,SAAS;wBACX,CAAC;oBACH,OACE,IAAI,EAAE,SAAS,EAAE;wBACf,MAAM,OAAO,EAAE,SAAS,CACtB;4BACE,GAAG,EAAE,GAAG,CAAC,QAAQ,CAAC;4BAClB,GAAG,EAAE,GAAG,CAAC,QAAQ,CAAC;4BAClB,IAAI;4BACJ,GAAG;wBACL,GACA;wBAEF,KAAK,IAAI,CAAC;oBACZ,CAAC;gBAEL,OAAO;oBACL,cAAc;oBACd,IAAI,OAAO,EAAE,SAAS,KAAK,aAAa;wBACtC,MAAM,KAAK,EAAE,SAAS;wBACtB,MAAM,MAAM,CAAA,GAAA,aAAK,CAAC,CAAC,GAAG,CAAC,QAAQ;wBAC/B,IAAI;wBACJ,IAAI,aAAa,KAAK;wBACtB,IAAI,EAAE,KAAK,IAAI,MAAM,OAAO,CAAC,EAAE,KAAK,GAClC,EAAE,KAAK,CAAC,OAAO,CAAC,SAAU,OAAY,EAAE;4BACtC,IACE,AAAC,QAAQ,KAAK,IACZ,QAAQ,KAAK,CAAC,EAAE,IAChB,QAAQ,KAAK,CAAC,EAAE,KAAK,MACtB,QAAQ,KAAK,IACZ,QAAQ,KAAK,CAAC,GAAG,IACjB,QAAQ,KAAK,CAAC,GAAG,KAAK,KACxB;gCACA,WAAW,QAAQ,OAAO;gCAC1B,aAAa,IAAI;4BACnB,CAAC;wBACH;wBAEF,IAAI,cAAc,EAAE,SAAS,EAAE;4BAC7B,IAAI,aAAa,KAAK;gCACpB,MAAM,OAAO,EAAE,SAAS,CACtB;oCAAE,IAAI;oCAAI,KAAK;oCAAK,IAAI;oCAAa,GAAG;gCAAS,GACjD;gCAEF,KAAK,IAAI,CAAC;gCACV,QAAQ,IAAI,CAAC,IAAI,CAAC;oCAAE,MAAM;oCAAM,GAAG;gCAAS;gCAC5C,OAAO,EAAE;gCACT,SAAS;4BACX,OAAO,IAAI,aAAa,KAAK;gCAC3B,QAAQ,IAAI,CAAC,IAAI,CAAC;oCAAE,MAAM;oCAAM,GAAG;gCAAS;gCAC5C,MAAM,OAAO,EAAE,SAAS,CACtB;oCAAE,IAAI;oCAAI,KAAK;oCAAK,IAAI;oCAAa,GAAG;gCAAS,GACjD;gCAEF,OAAO;oCAAC;iCAAK;gCACb,SAAS;4BACX,OAAO,IAAI,aAAa,KAAK;gCAC3B,QAAQ,IAAI,CAAC,IAAI,CAAC;oCAAE,MAAM;oCAAM,GAAG;gCAAS;gCAC5C,MAAM,OAAO,EAAE,SAAS,CACtB;oCAAE,IAAI;oCAAI,KAAK;oCAAK,IAAI;oCAAa,GAAG;gCAAS,GACjD;gCAEF,QAAQ,IAAI,CAAC,IAAI,CAAC;oCAAE,MAAM;wCAAC;qCAAK;oCAAE,GAAG;gCAAS;gCAC9C,OAAO,EAAE;gCACT,SAAS;4BACX,OAAO;gCACL,QAAQ,IAAI,CAAC,IAAI,CAAC;oCAAE,MAAM;oCAAM,GAAG;gCAAS;gCAC5C,OAAO,EAAE;gCACT,SAAS;4BACX,CAAC;wBACH,OACE,IAAI,EAAE,SAAS,EAAE;4BACf,MAAM,OAAO,EAAE,SAAS,CACtB;gCAAE,IAAI;gCAAI,KAAK;gCAAK,IAAI;gCAAa,GAAG;4BAAS,GACjD;4BAEF,KAAK,IAAI,CAAC;wBACZ,CAAC;oBAEL,OACE,IAAI,EAAE,SAAS,EACb,KAAK,IAAI,CACP,EAAE,SAAS,CAAC;wBAAE,IAAI;wBAAG,IAAI;wBAAa,GAAG;oBAAS,GAAG;gBAI7D,CAAC;YACH;YAEA,IAAI,KAAK,MAAM,GAAG,GAAG,QAAQ,IAAI,CAAC,IAAI,CAAC;gBAAE,MAAM;gBAAM,GAAG;YAAS;YACjE,IAAI,SAAS,MAAM;gBACjB,MAAM,SAAS;oBACb,GAAG,AAAC,KAAc,SAAS,EAAE,SAAS;oBACtC,GAAG,KAAK,QAAQ;gBAClB;gBACA,MAAM,UAAU,CAAA,GAAA,cAAO,AAAD,EAAE,cAAc,CAAC,KAAK,MAAM,EAAE,QAAQ;gBAC5D,IAAI,WAAW,QAAQ,MAAM,GAAG,GAC9B,OAAO,CAAC,GAAG;gBAEb,QAAQ,CAAC,GAAG;gBACZ,QAAQ,GAAG,GAAG,AAAC,KAAc,SAAS;YACxC,OAAO,IAAI,SAAS,OAAO;gBACzB,MAAM,WAAW;oBAAE,GAAG,AAAC,KAAe,OAAO;oBAAE,GAAG;gBAAW;gBAC7D,MAAM,UAAU,CAAA,GAAA,cAAO,AAAD,EAAE,eAAe,CAAC,KAAK,MAAM,EAAE,QAAQ;gBAC7D,IAAI,WAAW,QAAQ,MAAM,GAAG,GAC9B,SAAS,CAAC,GAAG;gBAEf,QAAQ,CAAC,GAAG;YACd,CAAC;YACD,SAAS,IAAI,CAAC;QAChB,CAAC;IACH;IAEA,OAAO;AACT;AA0BO,MAAM,QAAQ,CAAC,GAAgB,SAAiC;IACrE,IAAI,EAAE,EAAE,EAAE;QACR,IAAI,AAAC,EAAE,EAAE,CAAY,CAAC,EACpB,OAAO,SAAS,GAAG;aACd,IAAI,AAAC,EAAE,EAAE,CAAa,CAAC,EAC5B,OAAO,OAAO;IAElB,CAAC;IACD,MAAM,IAAI,MAAM,CAAC,UAAU,CAAC,EAAE;AAChC;AAEA,IAAI,cAAiB,QACnB;IAAA,IAAI,QAAQ,IAAI,CAAC,MAAM,IAAI,GAAG;QAC5B,MAAM,OAAO,QAAQ,IAAI,CAAC,EAAE;QAC5B,SAAS;YAAE,IAAI;gBAAE,GAAG;YAAK;QAAE,GAAG,IAAI,CAAC,SAAU,MAAM,EAAE;YACnD,QAAQ,GAAG,CAAC;QACd;IACF,CAAC;AAAD,CACD","sources":["src/index.ts"],"sourcesContent":["import { Address, OpCode, Tx, TxIn, TxOut } from \"@ts-bitcoin/core\";\r\nimport RpcClient, { Config } from \"bitcoind-rpc\";\r\n\r\nconst fromHash = function (o: ParseConfig, config?: Config): Promise<BpuTx> {\r\n  if (!config) {\r\n    console.log(\"split from hash without config\");\r\n    config = {\r\n      protocol: \"http\",\r\n      user: process.env.BITCOIN_USERNAME\r\n        ? process.env.BITCOIN_USERNAME\r\n        : \"root\",\r\n      pass: process.env.BITCOIN_PASSWORD\r\n        ? process.env.BITCOIN_PASSWORD\r\n        : \"bitcoin\",\r\n      host: process.env.BITCOIN_IP ? process.env.BITCOIN_IP : \"127.0.0.1\",\r\n      port: process.env.BITCOIN_PORT ? process.env.BITCOIN_PORT : \"8332\",\r\n    };\r\n  }\r\n  const rpc = new RpcClient(config);\r\n  return new Promise(function (resolve, reject) {\r\n    if ((o.tx as ByTxId)?.h) {\r\n      rpc.getRawTransaction(\r\n        (o.tx as ByTxId).h,\r\n        async function (err, transaction) {\r\n          if (err) {\r\n            reject(err);\r\n          } else {\r\n            if (o.tx) {\r\n              (o.tx as ByRawTx).r = transaction.result;\r\n              const result = await fromTx(o);\r\n              resolve(result);\r\n            } else {\r\n              reject(new Error(`Failed to get raw tx from RPC endpoint`));\r\n            }\r\n          }\r\n        }\r\n      );\r\n    }\r\n  });\r\n};\r\n\r\ntype Cell = {\r\n  op?: number;\r\n  ops?: string;\r\n  b?: string;\r\n  s?: string;\r\n  ii: number;\r\n  i: number;\r\n  h?: string;\r\n  f?: string;\r\n  ls?: string;\r\n  lh?: string;\r\n  lf?: string;\r\n  lb?: string;\r\n};\r\n\r\ntype Tape = {\r\n  cell: Cell[];\r\n  i: number;\r\n};\r\n\r\ntype Out = {\r\n  tape: Tape[];\r\n  i: number;\r\n  e: {\r\n    i: number;\r\n    a: string | false;\r\n    v: number;\r\n  };\r\n};\r\n\r\ntype In = {\r\n  i: number;\r\n  e: {\r\n    h: string;\r\n    a: string;\r\n    v?: number;\r\n  };\r\n};\r\n\r\nexport type BpuTx = {\r\n  out: Out[];\r\n  in?: In[];\r\n  tx: {\r\n    h?: string;\r\n    r?: string;\r\n  };\r\n  lock?: number;\r\n};\r\n\r\nconst fromTx = function (o: ParseConfig): Promise<BpuTx> {\r\n  const transaction = (o.tx as ByRawTx).r;\r\n  return new Promise(function (resolve, reject) {\r\n    if (transaction) {\r\n      const gene = Tx.fromHex(transaction);\r\n      const inputs = gene.txIns ? collect(o, \"in\", gene.txIns) : [];\r\n      const outputs = gene.txOuts ? collect(o, \"out\", gene.txOuts) : [];\r\n      resolve({\r\n        tx: { h: gene.hash().toString() },\r\n        in: inputs as In[],\r\n        out: outputs as Out[],\r\n        lock: gene.nLockTime,\r\n      });\r\n    } else {\r\n      reject(new Error(`No transaction`));\r\n    }\r\n  });\r\n};\r\n\r\nconst collect = function (\r\n  o: ParseConfig,\r\n  type: any,\r\n  xputs: (TxIn | TxOut)[]\r\n): In[] | Out[] {\r\n  const xputsres: any = [];\r\n  if (!o.transform)\r\n    o.transform = function (r: any) {\r\n      return r;\r\n    };\r\n  xputs.forEach(function (xput, xput_index) {\r\n    if (xput.script) {\r\n      const xputres = { i: xput_index, tape: [] } as any;\r\n      let tape_i = 0;\r\n      let cell_i = 0;\r\n      let cell: any = [];\r\n      xput.script.chunks.forEach(function (c, chunk_index) {\r\n        if (c.buf) {\r\n          const b = c.buf.toString(\"base64\");\r\n          const s = c.buf.toString(\"utf8\");\r\n          let splitter: string | undefined;\r\n          let isSplitter = false;\r\n          if (o.split && Array.isArray(o.split)) {\r\n            o.split.forEach(function (setting: any) {\r\n              if (\r\n                (setting.token && setting.token.s && setting.token.s === s) ||\r\n                (setting.token && setting.token.b && setting.token.b === b)\r\n              ) {\r\n                splitter = setting.include;\r\n                isSplitter = true;\r\n              }\r\n            });\r\n          }\r\n          if (isSplitter && o.transform) {\r\n            if (splitter === \"l\") {\r\n              const item = o.transform(\r\n                {\r\n                  b: c.buf.toString(\"base64\"),\r\n                  s: c.buf.toString(\"utf8\"),\r\n                  ii: chunk_index,\r\n                  i: cell_i++,\r\n                },\r\n                c\r\n              );\r\n\r\n              cell.push(item);\r\n              xputres.tape.push({ cell: cell, i: tape_i++ });\r\n              cell = [];\r\n              cell_i = 0;\r\n            } else if (splitter === \"r\") {\r\n              xputres.tape.push({ cell: cell, i: tape_i++ });\r\n              const item = o.transform(\r\n                {\r\n                  b: c.buf.toString(\"base64\"),\r\n                  s: c.buf.toString(\"utf8\"),\r\n                  ii: chunk_index,\r\n                  i: cell_i++,\r\n                },\r\n                c\r\n              );\r\n              cell = [item];\r\n              cell_i = 1;\r\n            } else if (splitter === \"c\") {\r\n              xputres.tape.push({ cell: cell, i: tape_i++ });\r\n              const item = o.transform(\r\n                {\r\n                  b: c.buf.toString(\"base64\"),\r\n                  s: c.buf.toString(\"utf8\"),\r\n                  ii: chunk_index,\r\n                  i: 0,\r\n                },\r\n                c\r\n              );\r\n              xputres.tape.push({ cell: [item], i: tape_i++ });\r\n              cell = [];\r\n              cell_i = 0;\r\n            } else {\r\n              xputres.tape.push({ cell: cell, i: tape_i++ });\r\n              cell = [];\r\n              cell_i = 0;\r\n            }\r\n          } else {\r\n            if (o.transform) {\r\n              const item = o.transform(\r\n                {\r\n                  b: c.buf.toString(\"base64\"),\r\n                  s: c.buf.toString(\"utf8\"),\r\n                  ii: chunk_index,\r\n                  i: cell_i++,\r\n                },\r\n                c\r\n              );\r\n              cell.push(item);\r\n            }\r\n          }\r\n        } else {\r\n          // Opcode case\r\n          if (typeof c.opCodeNum !== \"undefined\") {\r\n            const op = c.opCodeNum;\r\n            const ops = OpCode[op].toString();\r\n            let splitter: string | undefined;\r\n            let isSplitter = false;\r\n            if (o.split && Array.isArray(o.split)) {\r\n              o.split.forEach(function (setting: any) {\r\n                if (\r\n                  (setting.token &&\r\n                    setting.token.op &&\r\n                    setting.token.op === op) ||\r\n                  (setting.token &&\r\n                    setting.token.ops &&\r\n                    setting.token.ops === ops)\r\n                ) {\r\n                  splitter = setting.include;\r\n                  isSplitter = true;\r\n                }\r\n              });\r\n            }\r\n            if (isSplitter && o.transform) {\r\n              if (splitter === \"l\") {\r\n                const item = o.transform(\r\n                  { op: op, ops: ops, ii: chunk_index, i: cell_i++ },\r\n                  c\r\n                );\r\n                cell.push(item);\r\n                xputres.tape.push({ cell: cell, i: tape_i++ });\r\n                cell = [];\r\n                cell_i = 0;\r\n              } else if (splitter === \"r\") {\r\n                xputres.tape.push({ cell: cell, i: tape_i++ });\r\n                const item = o.transform(\r\n                  { op: op, ops: ops, ii: chunk_index, i: cell_i++ },\r\n                  c\r\n                );\r\n                cell = [item];\r\n                cell_i = 1;\r\n              } else if (splitter === \"c\") {\r\n                xputres.tape.push({ cell: cell, i: tape_i++ });\r\n                const item = o.transform(\r\n                  { op: op, ops: ops, ii: chunk_index, i: cell_i++ },\r\n                  c\r\n                );\r\n                xputres.tape.push({ cell: [item], i: tape_i++ });\r\n                cell = [];\r\n                cell_i = 0;\r\n              } else {\r\n                xputres.tape.push({ cell: cell, i: tape_i++ });\r\n                cell = [];\r\n                cell_i = 0;\r\n              }\r\n            } else {\r\n              if (o.transform) {\r\n                const item = o.transform(\r\n                  { op: op, ops: ops, ii: chunk_index, i: cell_i++ },\r\n                  c\r\n                );\r\n                cell.push(item);\r\n              }\r\n            }\r\n          } else {\r\n            if (o.transform) {\r\n              cell.push(\r\n                o.transform({ op: c, ii: chunk_index, i: cell_i++ }, c)\r\n              );\r\n            }\r\n          }\r\n        }\r\n      });\r\n\r\n      if (cell.length > 0) xputres.tape.push({ cell: cell, i: tape_i++ });\r\n      if (type === \"in\") {\r\n        const sender = {\r\n          h: (xput as TxIn).txHashBuf?.toString(\"hex\"),\r\n          i: xput.scriptVi,\r\n        } as any;\r\n        const address = Address.fromTxInScript(xput.script).toString();\r\n        if (address && address.length > 0) {\r\n          sender.a = address;\r\n        }\r\n        xputres.e = sender;\r\n        xputres.seq = (xput as TxIn).nSequence;\r\n      } else if (type === \"out\") {\r\n        const receiver = { v: (xput as TxOut).valueBn, i: xput_index } as any;\r\n        const address = Address.fromTxOutScript(xput.script).toString();\r\n        if (address && address.length > 0) {\r\n          receiver.a = address;\r\n        }\r\n        xputres.e = receiver;\r\n      }\r\n      xputsres.push(xputres);\r\n    }\r\n  });\r\n\r\n  return xputsres;\r\n};\r\n\r\ntype ByRawTx = {\r\n  r: string;\r\n};\r\n\r\ntype ByTxId = {\r\n  h: string;\r\n};\r\n\r\ntype SplitConfig = {\r\n  token: {\r\n    op?: number;\r\n    ops?: string;\r\n    s?: string;\r\n    b?: string;\r\n  };\r\n  include?: string;\r\n};\r\n\r\nexport type ParseConfig = {\r\n  tx: ByRawTx | ByTxId;\r\n  split?: SplitConfig[];\r\n  transform?: (o: any, c: any) => Object;\r\n};\r\n\r\nexport const parse = (o: ParseConfig, config?: any): Promise<BpuTx> => {\r\n  if (o.tx) {\r\n    if ((o.tx as ByTxId).h) {\r\n      return fromHash(o, config);\r\n    } else if ((o.tx as ByRawTx).r) {\r\n      return fromTx(o);\r\n    }\r\n  }\r\n  throw new Error(`Invalid Tx`);\r\n};\r\n\r\nif (require.main === module) {\r\n  if (process.argv.length >= 3) {\r\n    const hash = process.argv[2];\r\n    fromHash({ tx: { h: hash } }).then(function (result) {\r\n      console.log(result);\r\n    });\r\n  }\r\n}\r\n\r\nexport type { Config } from \"bitcoind-rpc\";\r\n"],"names":[],"version":3,"file":"bpu.js.map","sourceRoot":"../"}